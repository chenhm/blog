<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, user-scalable=no">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="manifest" href="/manifest.json">
    <link href="/static/asciidoctor.min.css" rel="stylesheet"/>
    <link href="/static/build.css" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/themes/prism.min.css" integrity="sha256-77qGXu2p8NpfcBpTjw4jsMeQnz0vyh74f5do0cWjQ/Q=" crossorigin="anonymous" />
</head>
<body>
<div id='app'>
    <header class="header">
        <div class="container">
            <!--start: Navigation -->
            <a href="/" class="brand">On the Road</a>
<!--            <ul class="nav">-->
<!--                <li><a href="/list/">Blogs</a></li>-->
<!--                <li><a href="/slides/">Slides</a></li>-->
<!--                <li><a href="/about/">About</a></li>-->
<!--            </ul>-->
        </div>
        <!--end: Navigation -->
        <div style="clear: both"></div>
        <search-bar v-if="isPageList"></search-bar>
    </header>

<section class="post-view">
    <article>
     
     <h1>Spring Cloud 概览</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_基础概念">1. 基础概念</a>
<ul class="sectlevel2">
<li><a href="#_服务发现_service_discovry">1.1. 服务发现 Service Discovry</a></li>
<li><a href="#_负载均衡_load_balancer_failover">1.2. 负载均衡 Load Balancer &amp; Failover</a></li>
<li><a href="#_声明式rest客户端_declarative_rest_client">1.3. 声明式REST客户端 Declarative REST Client</a></li>
<li><a href="#_断路器_circuit_breaker">1.4. 断路器 Circuit Breaker</a></li>
<li><a href="#_分布式追踪_tracing">1.5. 分布式追踪 Tracing</a></li>
<li><a href="#_配置中心_config">1.6. 配置中心 Config</a></li>
<li><a href="#_消息服务_stream_bus">1.7. 消息服务 Stream &amp; Bus</a></li>
<li><a href="#_api_gateway">1.8. API Gateway</a></li>
</ul>
</li>
<li><a href="#_其他">2. 其他</a>
<ul class="sectlevel2">
<li><a href="#_service_mesh">2.1. Service Mesh</a></li>
<li><a href="#_cloud_native">2.2. Cloud Native</a></li>
<li><a href="#_dubbo_vs_spring_cloud">2.3. Dubbo vs Spring Cloud</a></li>
</ul>
</li>
<li><a href="#_参考">参考</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://chenhm.com">Chen Hongming</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_基础概念">1. 基础概念</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring cloud 是目前最热门的 Microservice 框架，其基础是Netfilex OSS里面服务管理相关的项目，由于组件众多，并且很多依赖第三方库，导致初学者容易迷惑。
这里简单整理了Spring cloud涉及的常见概念，作为入门参考。这篇文章中的一些例子可以在 <a href="https://github.com/chenhm/spring-cloud-demo" class="bare">https://github.com/chenhm/spring-cloud-demo</a> 找到，小图都可以通过右键新开窗口查看大图。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://www.plantuml.com/plantuml/svg/ZLZhJzj84Fzy_YjMz7JSIJYl0gKHYWe9wUD4oq5QdSgXQcrFx2ssrxUx9eIg__lDFXpMIKhF7u8zyvk7P-TbNab5XQgBF92thAoee0N9Q9ai15CAIg943HxhMq3msYruoUDCy08im10JcDCwLpEuLoSvIyi2IaLY_05X05lvESoLuKOqlaq5hyjap7CkoBEfliu2mvGPJVY2bIcPqrnQUrG8ld3O_SCN-o-d5di9iQ9bciCf5ma8XnYRQmsmOV9WEfZsh9enBofUeeijDSvG6x2kvkpWRDoe-IWXfX9-fAHXFwLYp4ibUDvIqUiTzSU7BVQwYeE3oMHyObNCyUpWHmegbAJfLhRXdwIRKJWwsd_XCTTjJwRJtkGe2Bu7mQvYAWToLGbzVEESrmcPGPoLY4oNv4gXR118P2iWl-fi9DVzm_l-ONV_1jEjPw_1mDreGhy_EFtovNGmw5j2iVpYhcLX4Rrp-tpUYFIAudMlzxeeLWJ_qdx6DenavrYo1nZsZqQ-opk4IY8DmJm7WMYoYEoy1pNFsRt1bFR-4bstMQhZiuA4CHVWuyZrzSrD2_bcAPL0nd6iGpcCyXf6rgN1O7JycwBfw9_I-TWVZPc8QwP8983UWZ2gCwV1gDwYUK9b5d4g4X-z8cw8dTK2Rgbdymh47Ok194p6_0x4qkW10zkGdW9MkYSyWJZ7JgBO7P0tiza5YNE6GADYhh6e8LEgaiDkDsKggwDEp8lkXmfAewfhG6qRbooAk6_ayc9C5YXCSauJx2mvBMCRTc6WsssuC-fQJDl4h1OHAy6FWiAG5yXF1QHKSHjxPN6UWG8ILXV6W3lpK67wHvZzNHVxC6c27phvK1hjuQFsyB3tykY03k2WdypRlbrLEXKHu-S5ptEawlmj06t4qcMmWpuTWHMioSqcMyDmr2HCcovOcYbasYpOa367ja6rWTuWhwpRrcMIejDf6twaEYM6scI-XrxbzP3Wq6AeLST4CbEv6PTgGz0TmP30dGwlFGc3QWxtPzhZl9Pww9csOXgU2woTdWbLDCAcJtPEL4wbTsflox20WeibrXPEHybuINFY0HIIYGJ1GAxKc8EbMjFJXseWtGMxPMlfW-NCFHjdznL7vrpQ4AoMT-T_s-pHo9zaZeQqzNzY3p48cdicPeBEvomcdvYiQSuUi1tmqfYuS-3_MK0DFEJO7qB9Qn53IEEu5pyVzFlFvz1svNDT-swS9IaE9jlDFFBlECbqvUnvPxhdyGL8ffjMlDp3aCGrJgxb7yRx1zJ_T7mqektJYOWpochPAjvopj9QcB2GWfO8BPecIHq--6LL_gmiTVDlQy0tg7ajoGHojchIii5wNYuMYywAtc6ys_XdKafNH1DbGpRl65vdB4cWlC5oVNJ8veVFM-d5KdZiFLgdqRv6C_9DoUnCc2wng5QGu999Opo5dM-joE7YakafWanR1Pd6WO_HSsDcXSd9nTjcgWf8_A6Q0Ux08wD29vAp5gnLwvXAYPkne0Q8QvjS0vpXAoci6T0XiKFHKjguywNyDxVA7vS8-sQUvnyZFALt558trR-QstNKRA7NT44-imftT9k4vjO0lrihtZkPE7kgrbcUi4KPgdxN8NP2N5xMMUuDVQxLiLNGOpqjQ6BKyF0rtEjYNijM2M_VHM83ixj8KoKvr2hp5v4jwMLAn019IzWMv7RXBbhLZHgInZH2MzAdhUAk1AyeZdJiuqh_Ol6KAVW86WikiT2REMBqHhLiAJtM3jp2Q6mnnrttR9smn7O0NAVo37qumJSTx96hgm-klrj8Isw2QKkcELyOY4xYEJwqLPiHwIa-1woK5C94OEknMMd7Q4lia_uQzALqezE9YAuAK7PZkTCWrwsmMPdUqB6BkEvLzYuqvD1WTVjoBUHvLVaDupLJtjEVTEuM5VjyIQE8gVE_TBO5BWaw-kjKJtlJLuQuGfjUuwfDVqY2xgqxA_nZ1GNUnm89wmgReStAxGpCcIsC9jfRM6ujQJ6GR4BGfZQhcHkUspp3vDhGr2mnw_GcIGATaIlbpft0fN-dhZ0KEk3kt2t1nhn5MeMzPKV7NMirOKMFcyJK3kW1P0pf4Z_kN3_35HcdJQTPFeVOLQjSpm7y-ConKPM9_I_3xaRpnu-yflbZ0I45_nZCY0p9nUGZmS7q_kejgVM-k9BtFicC0lr9jYa-nb71y00XsBKUQ4VGfLVufoxo_m00" alt="ZLZhJzj84Fzy YjMz7JSIJYl0gKHYWe9wUD4oq5QdSgXQcrFx2ssrxUx9eIg  lDFXpMIKhF7u8zyvk7P TbNab5XQgBF92thAoee0N9Q9ai15CAIg943HxhMq3msYruoUDCy08im10JcDCwLpEuLoSvIyi2IaLY 05X05lvESoLuKOqlaq5hyjap7CkoBEfliu2mvGPJVY2bIcPqrnQUrG8ld3O SCN o d5di9iQ9bciCf5ma8XnYRQmsmOV9WEfZsh9enBofUeeijDSvG6x2kvkpWRDoe IWXfX9 fAHXFwLYp4ibUDvIqUiTzSU7BVQwYeE3oMHyObNCyUpWHmegbAJfLhRXdwIRKJWwsd XCTTjJwRJtkGe2Bu7mQvYAWToLGbzVEESrmcPGPoLY4oNv4gXR118P2iWl fi9DVzm l ONV 1jEjPw 1mDreGhy EFtovNGmw5j2iVpYhcLX4Rrp tpUYFIAudMlzxeeLWJ qdx6DenavrYo1nZsZqQ opk4IY8DmJm7WMYoYEoy1pNFsRt1bFR 4bstMQhZiuA4CHVWuyZrzSrD2 bcAPL0nd6iGpcCyXf6rgN1O7JycwBfw9 I TWVZPc8QwP8983UWZ2gCwV1gDwYUK9b5d4g4X z8cw8dTK2Rgbdymh47Ok194p6 0x4qkW10zkGdW9MkYSyWJZ7JgBO7P0tiza5YNE6GADYhh6e8LEgaiDkDsKggwDEp8lkXmfAewfhG6qRbooAk6 ayc9C5YXCSauJx2mvBMCRTc6WsssuC fQJDl4h1OHAy6FWiAG5yXF1QHKSHjxPN6UWG8ILXV6W3lpK67wHvZzNHVxC6c27phvK1hjuQFsyB3tykY03k2WdypRlbrLEXKHu S5ptEawlmj06t4qcMmWpuTWHMioSqcMyDmr2HCcovOcYbasYpOa367ja6rWTuWhwpRrcMIejDf6twaEYM6scI XrxbzP3Wq6AeLST4CbEv6PTgGz0TmP30dGwlFGc3QWxtPzhZl9Pww9csOXgU2woTdWbLDCAcJtPEL4wbTsflox20WeibrXPEHybuINFY0HIIYGJ1GAxKc8EbMjFJXseWtGMxPMlfW NCFHjdznL7vrpQ4AoMT T s pHo9zaZeQqzNzY3p48cdicPeBEvomcdvYiQSuUi1tmqfYuS 3 MK0DFEJO7qB9Qn53IEEu5pyVzFlFvz1svNDT swS9IaE9jlDFFBlECbqvUnvPxhdyGL8ffjMlDp3aCGrJgxb7yRx1zJ T7mqektJYOWpochPAjvopj9QcB2GWfO8BPecIHq  6LL gmiTVDlQy0tg7ajoGHojchIii5wNYuMYywAtc6ys XdKafNH1DbGpRl65vdB4cWlC5oVNJ8veVFM d5KdZiFLgdqRv6C 9DoUnCc2wng5QGu999Opo5dM joE7YakafWanR1Pd6WO HSsDcXSd9nTjcgWf8 A6Q0Ux08wD29vAp5gnLwvXAYPkne0Q8QvjS0vpXAoci6T0XiKFHKjguywNyDxVA7vS8 sQUvnyZFALt558trR QstNKRA7NT44 imftT9k4vjO0lrihtZkPE7kgrbcUi4KPgdxN8NP2N5xMMUuDVQxLiLNGOpqjQ6BKyF0rtEjYNijM2M VHM83ixj8KoKvr2hp5v4jwMLAn019IzWMv7RXBbhLZHgInZH2MzAdhUAk1AyeZdJiuqh Ol6KAVW86WikiT2REMBqHhLiAJtM3jp2Q6mnnrttR9smn7O0NAVo37qumJSTx96hgm klrj8Isw2QKkcELyOY4xYEJwqLPiHwIa 1woK5C94OEknMMd7Q4lia uQzALqezE9YAuAK7PZkTCWrwsmMPdUqB6BkEvLzYuqvD1WTVjoBUHvLVaDupLJtjEVTEuM5VjyIQE8gVE TBO5BWaw kjKJtlJLuQuGfjUuwfDVqY2xgqxA nZ1GNUnm89wmgReStAxGpCcIsC9jfRM6ujQJ6GR4BGfZQhcHkUspp3vDhGr2mnw GcIGATaIlbpft0fN dhZ0KEk3kt2t1nhn5MeMzPKV7NMirOKMFcyJK3kW1P0pf4Z kN3 35HcdJQTPFeVOLQjSpm7y ConKPM9 I 3xaRpnu yflbZ0I45 nZCY0p9nUGZmS7q kejgVM k9BtFicC0lr9jYa nb71y00XsBKUQ4VGfLVufoxo m00">
</div>
<div class="title">Figure 1. Spring cloud technology stack</div>
</div>
<div class="paragraph">
<p>上图是我列出的仅仅一些基础组件依赖关系，是不是显得有点眼花缭乱，但如果我们思考 Microservice 所面临的问题，服务框架应该如何解决这些问题，那么 Spring cloud 的组件关系将会变得清晰自然。</p>
</div>
<div class="paragraph">
<p>在 <a href="https://martinfowler.com/articles/microservices.html">Martin Fowler</a> 的网站我们可以看到其对 Microservice 有这样一段描述：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>a single application as a suite of small services, each running in its own process and <strong>communicating with</strong> lightweight mechanisms, often an <strong>HTTP resource API</strong></p>
</div>
</blockquote>
<div class="attribution">
&#8212; James Lewis and Martin Fowler<br>
<cite>ThoughtWorks</cite>
</div>
</div>
<div class="paragraph">
<p>当服务粒度变细之后，必然存在大量的服务间通信，但服务A如何知道服务B的endpoint呢？这时我们需要引入服务发现机制。</p>
</div>
<div class="sect2">
<h3 id="_服务发现_service_discovry">1.1. 服务发现 Service Discovry</h3>
<div class="paragraph">
<p>服务发现实际上就是根据服务名找到提供对应服务的主机名或IP地址、端口、context path等信息，由于端口和context path往往有默认值，所以重点关注的是 name &#8594; IP 的过程。这似乎跟 DNS 一样？是的，非常流行的服务发现产品 <a href="https://www.consul.io/docs/internals/architecture.html">Consul</a> 就可以提供基于 DNS 协议的查找，并通过设置TTL为0避免缓存。</p>
</div>
<div class="paragraph">
<p>Spring cloud 默认使用 Netfilx 的 Eureka 作为服务注册中心，但也支持多种主流注册中心。注册中心需要记录整个集群的状态，并能随时响应客户端的查询。符合 AP 要求的 Consul 和 Eureka 是相对较好的选择。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-right valign-top">Features</th>
<th class="tableblock halign-center valign-top">Consul</th>
<th class="tableblock halign-center valign-top">Eureka</th>
<th class="tableblock halign-center valign-top">Zookeeper</th>
<th class="tableblock halign-center valign-top">Etcd</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-right valign-top"><p class="tableblock">CAP</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">CP/AP</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">AP</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">CP</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">CP</p></td>
</tr>
<tr>
<th class="tableblock halign-right valign-top"><p class="tableblock">Language</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">Go</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Java</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Java</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Go</p></td>
</tr>
<tr>
<th class="tableblock halign-right valign-top"><p class="tableblock">Consensus protocol</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">Raft, stale mode</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No, broadcast async replication</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">ZAB</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Raft</p></td>
</tr>
<tr>
<th class="tableblock halign-right valign-top"><p class="tableblock">KV</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<th class="tableblock halign-right valign-top"><p class="tableblock">Security</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">acl/https</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">acl</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">https</p></td>
</tr>
<tr>
<th class="tableblock halign-right valign-top"><p class="tableblock">Interface</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">REST/DNS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">REST</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Client</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">REST/grpc</p></td>
</tr>
<tr>
<th class="tableblock halign-right valign-top"><p class="tableblock">Service health check</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">tcp/http/script</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">client heartbeats</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">keepalive</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">heartbeats</p></td>
</tr>
<tr>
<th class="tableblock halign-right valign-top"><p class="tableblock">Self check</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">metrics</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">metrics</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">metrics</p></td>
</tr>
<tr>
<th class="tableblock halign-right valign-top"><p class="tableblock">Multi-data center</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">Gossip</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Consul 因为有两级结构，CAP模式较为特别，Consul server 通过 <a href="http://thesecretlivesofdata.com/raft">Raft</a> 协议组成一个CP集群，数据写操作都由 leader 处理，保证强一致性。而由Consul agent 和 server 组成的完整集群则是一个 AP 系统，通过 Gossip 协议向 agent 广播 leader 状态，agent 进行查询操作的时候甚至可以使用 stale mode 完全不考虑一致性。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/${conf.repo}/${conf.branch}/${conf.path}/images/consul.png" alt="consul">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_负载均衡_load_balancer_failover">1.2. 负载均衡 Load Balancer &amp; Failover</h3>
<div class="paragraph">
<p>不管是 SD 为了提高可用性牺牲了一致性，还是因为 health check 不够及时，我们从 SD 拿到的 service 列表总有一些是过期的，对应的需要有 Failover 机制在一个服务实例失效的时候连接其他实例。这时有两个选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Client-side load balance: 客户端 LB 实现较为简单，直接在客户端完成服务查找和调用，Spring cloud 的实现是基于 <a href="https://github.com/Netflix/ribbon">Netflix/ribbon</a> 的，体现在代码上就是 <code>@LoadBalanced</code> 注解。</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableEurekaClient
@SpringBootApplication
public class ClientApplication {

    @LoadBalanced
    @Bean
    RestTemplate restTemplate(){
        return new RestTemplate();
    }

	@RequestMapping(path = "/names", method = RequestMethod.GET)
    public Collection&lt;String&gt; getUsers() {
        return this.restTemplate.exchange(
                "http://service-name/users", GET, null, null)
                .getBody()
                .getContent()
                .stream()
                .collect(toList());
    }
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/${conf.repo}/${conf.branch}/${conf.path}/images/part7-clientsidelb.png" alt="part7 clientsidelb">
</div>
</div>
</li>
<li>
<p>Server-side load balance: 服务端 LB 需要新增一个反向代理模块，实现相对复杂，现在多体现为 <a href="http://microservices.io/patterns/apigateway">API Gateway</a> 模式，后面我们会单独介绍。</p>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/${conf.repo}/${conf.branch}/${conf.path}/images/part7-serversidelb.png" alt="part7 serversidelb">
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_声明式rest客户端_declarative_rest_client">1.3. 声明式REST客户端 Declarative REST Client</h3>
<div class="paragraph">
<p>基于 RestTemplate 编程并不方便，Spring cloud 使用 <a href="https://github.com/OpenFeign/feign">Feign</a> 实现声明式客户端，其效果跟 CXF 基于 <a href="https://github.com/jax-rs/spec/raw/master/spec.pdf">JAX-RS</a> 的 <code><a href="http://cxf.apache.org/docs/jax-rs-client-api.html">JAXRSClientFactory.create()</a></code> 差不多。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@FeignClient(
        name = "reservation-service"
)
public interface NamesFeignClient {
    @RequestMapping(value = "/reservations", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
    Resources&lt;Reservation&gt; reservations();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Feign 会根据上面的 interface 自动生成实现，调用非常简单</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Autowired
NamesFeignClient client;

public Resources&lt;Reservation&gt; getReservations(){
	return client.reservations();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_断路器_circuit_breaker">1.4. 断路器 Circuit Breaker</h3>
<div class="paragraph">
<p>即使有 LB，仍然可能会因为负载过高、网络抖动等原因无法正常调用，我们可以利用断路器进行服务降级，提升用户体验。</p>
</div>
<div class="sect3">
<h4 id="_hystrix">1.4.1. Hystrix</h4>
<div class="paragraph">
<p>Spring cloud 使用的 <a href="https://github.com/Netflix/Hystrix">Hystrix</a> 可以和 Feign 结合在一起简化编程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@FeignClient(
	name = "reservation-service",
	fallback = NamesFeignClient.NamesFeignClientFallback.class <b class="conum">(1)</b>
)
public interface NamesFeignClient {
    @RequestMapping(value = "/reservations", method = RequestMethod.GET,
			produces = MediaType.APPLICATION_JSON_VALUE)
    Resources&lt;Reservation&gt; reservations();

    @Component
    class NamesFeignClientFallback implements NamesFeignClient { <b class="conum">(2)</b>

        @Override
        public Resources&lt;Reservation&gt; reservations() {
            return new Resources(Arrays.asList(new Reservation(1L, "Frank")));
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>声明 fallback 的实现类</p>
</li>
<li>
<p>Fallback 必须实现原接口，当方法调用失败的时候，会调用 Fallback 类上的对应方法</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_hystrix_dashboard">1.4.2. Hystrix Dashboard</h4>
<div class="paragraph">
<p>一旦达到熔断条件，service 会直接调用 fallback 上的 mock 方法，不经过 SD、LB 等模块，所以 API 调用统计只能在断路器这个层面上实现。Hystrix 提供了子项目 <a href="https://github.com/Netflix/Hystrix/wiki/Dashboard">Hystrix Dashboard</a> 用于呈现 API 调用监控。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/wiki/Netflix/Hystrix/images/dashboard-example-1280.png" alt="hystrix-dashboard-netflix-api-example">
</div>
</div>
<div class="paragraph">
<p>启用 Hystrix Dashboard 也再次体现了 Spring cloud 基于注解的极简接口。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableHystrixDashboard
@SpringBootApplication
public class HystrixDashboardApplication {
	public static void main(String[] args) {
		SpringApplication.run(HystrixDashboardApplication.class, args);
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_turbine">1.4.3. Turbine</h4>
<div class="paragraph">
<p>Hystrix Dashboard 只能订阅单台 Hystrix 的访问统计信息，对于 Hystrix 集群我们需要利用 <a href="https://github.com/Netflix/Turbine/wiki">Turbine</a> 进行数据汇总，然后供  Dashboard 呈现。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_分布式追踪_tracing">1.5. 分布式追踪 Tracing</h3>
<div class="paragraph">
<p>为了追踪业务异常，必须知道一个请求从开始到结束经历了哪些节点。以前我们需要分析大量的日志才能得到这样的信息，一些 <a href="https://en.wikipedia.org/wiki/Application_performance_management">APM</a> 工具例如 <a href="https://www.appdynamics.com">AppDynamics</a>、 <a href="http://www.oneapm.com/">OneAPM</a> 虽然也可以协助追踪，但这些商业产品需要联网将业务数据上传给供应商，适用场景有限。于是受 <a href="https://research.google.com/pubs/pub36356.html">Google Dapper</a> 启发的 <a href="http://opentracing.io/">OpenTracing</a> 现在变得炙手可热。</p>
</div>
<div class="paragraph">
<p>OpenTracing 仅仅定义了一套规范和API用于在应用开发中设置埋点，实际的抓取存储日志、分析统计展现都由兼容 OpenTracing 的监控产品完成。</p>
</div>
<div class="paragraph">
<p>OpenTracing 核心只有两个概念</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Trace: 一条完整的调用链，通过传递一个全局唯一的TraceID追踪整个调用过程。</p>
</li>
<li>
<p>Span: 记录调用链上某个具体服务或方法的执行情况，通常包含调用开始时间、持续时间、调用方、被调用方、关键日志（例如http调用的应答码、url）、异常。Span是可以有父子关系的，例如一个服务调用内部包含多个执行方法。另外有一种`FollowsFrom`关系表明父子span之间不存在依赖，未来会进一步细分这种类型。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">单个Trace中，span间的因果关系</div>
<div class="content">
<pre>        [Span A]  ←←←(the root span)
            |
     +------+------+
     |             |
 [Span B]      [Span C] ←←←(Span C is a `ChildOf` Span A)
     |             |
 [Span D]      +---+-------+
               |           |
           [Span E]    [Span F] &gt;&gt;&gt; [Span G] &gt;&gt;&gt; [Span H]
                                       ↑
                                       ↑
                                       ↑
                         (Span G `FollowsFrom` Span F)</pre>
</div>
</div>
<div class="listingblock">
<div class="title">单个Trace中，span间的时间关系</div>
<div class="content">
<pre>––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–&gt; time

 [Span A···················································]
   [Span B··············································]
      [Span D··········································]
    [Span C········································]
         [Span E·······]        [Span F··] [Span G··] [Span H··]</pre>
</div>
</div>
<div class="paragraph">
<p>有规范就有实现，如今最流行的实现是 twitter 开源的 <a href="https://zipkin.io/">Zipkin</a>，但 Uber 开源的 <a href="https://github.com/jaegertracing/jaeger">Jaeger</a> 功能更强，并兼容 zipkin 协议，已成为 <a href="https://www.cncf.io/projects/">CNCF</a> 项目，有后来居上的趋势。另外国人开发的 <a href="http://skywalking.io/">SkyWalking APM</a> 目前是 Apache 孵化项目，weibo已在使用，值得关注。</p>
</div>
<div class="paragraph">
<p><a href="https://cloud.spring.io/spring-cloud-sleuth/">Spring Cloud Sleuth</a> 是一套类似 OpenTracing 的API，并且会对 Spring 各个组件做 instrument（详细请参考`spring-cloud-sleuth-core`包里的`org.springframework.cloud.sleuth.instrument`相关类），这样Spring cloud的项目只需要引入 Sleuth 库，不需要改任何代码，即可输出 tracing 信息到 Zipkin。</p>
</div>
</div>
<div class="sect2">
<h3 id="_配置中心_config">1.6. 配置中心 Config</h3>
<div class="paragraph">
<p>分布式集群的配置管理也是一个常见问题，一种方案是使用 <a href="https://www.ansible.com/">Ansible</a> 之类的维护工具或者 Kubernetes ConfigMap 之类的管理工具管理配置文件，一种是 Spring cloud 使用的配置中心，所有应用启动的时候从配置中心拉取配置信息。</p>
</div>
<div class="paragraph">
<p>Spring cloud config 利用 git 完成配置版本管理。config client 则新增了`bootstrap.properties`用于获取config server的信息，原来在Spring boot应用中`application.properties`的配置就统一交给了config server管理。</p>
</div>
<div class="listingblock">
<div class="title">bootstrap.properties</div>
<div class="content">
<pre class="highlight"><code class="language-properties" data-lang="properties">spring.application.name=demo
spring.cloud.config.uri=http://user:password@localhost:8888</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然 Spring cloud 也是可以和 ConfigMap 集成的，具体参考 <a href="https://github.com/spring-cloud-incubator/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-config">spring-cloud-kubernetes</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_消息服务_stream_bus">1.7. 消息服务 Stream &amp; Bus</h3>
<div class="paragraph">
<p>Spring Cloud Stream 提供了消息服务的抽象层，底层的消息队列可以是 <a href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka">Kafka</a> 或 <a href="https://github.com/spring-cloud/spring-cloud-stream-binder-rabbit">RabbitMQ</a>, Spring Cloud Bus 则在 Stream 基础上提供了总线服务。</p>
</div>
<div class="paragraph">
<p>Bus 的一个典型应用场景是配合 Config 使用，上面提到的 Config 拉取机制只能解决应用初始化阶段配置信息的加载，如果在运行过程中想更新一些配置项该如何做呢？Spring cloud 的解决方法是利用 Bus 进行配置项的广播，配合`@RefreshScope`即可刷新属性。</p>
</div>
</div>
<div class="sect2">
<h3 id="_api_gateway">1.8. API Gateway</h3>
<div class="paragraph">
<p>上面我们提到了 Server-side LB，既然有了这个负载均衡网关，在这里再做些权限控制、安全策略、流量监控、灰度发布，甚至协议转换、API拆分合并，似乎也很方便，于是 <a href="http://microservices.io/patterns/apigateway">API Gateway</a> 应运而生。API Gateway 极大的增强了 Service 的灵活性，Service 更多的专注于自身功能的实现而不用过多考虑调用方如何使用。</p>
</div>
<div class="paragraph">
<p>Sping cloud 继续使用 Netflix 的 <a href="https://github.com/Netflix/zuul">Zuul</a> 作为底层实现，应用代码只需要在Configuration类加上 <code>@EnableZuulProxy</code> 注解，Spring cloud 将自动从Service discovery获取服务信息，生成代理实现。</p>
</div>
<div class="paragraph">
<p>对于第三方API Gateway，基于 <a href="https://openresty.org/en/about.html">OpenResty</a> 的 <a href="https://getkong.org/">Kong</a> 是个热门选项。Nginx 虽然自身也一直在API Gateway领域发力，但打包了 Nginx + Lua 的 OpenResty 真正开创了服务器编程领域，在此基础上建立API Gateway自然事半功倍。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_其他">2. 其他</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_service_mesh">2.1. Service Mesh</h3>
<div class="paragraph">
<p>Service Mesh，服务网格，号称下一代微服务技术， <a href="http://bit.ly/8stepsawesome">8 Steps to Becoming Awesome with Kubernetes</a> 中认为其在明年会取代 Netflix OSS 中服务管理相关的组件。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/${conf.repo}/${conf.branch}/${conf.path}/images/microservices-2018.jpg" alt="microservices 2018">
</div>
</div>
<div class="paragraph">
<p>Service Mesh是什么呢？我们回顾上面的内容，可以看到微服务中很多问题都是跟网络通讯相关：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>服务注册与发现</p>
</li>
<li>
<p>负载均衡，进程间通讯，跨语言跨协议通讯</p>
</li>
<li>
<p>链路跟踪，日志与监控</p>
</li>
<li>
<p>限流，降级，熔断</p>
</li>
<li>
<p>路由策略，灰度发布</p>
</li>
<li>
<p>访问控制 (Spring Cloud Security)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果我们将网络层抽取出来，进行统一管理，服务提供方将只需要关注业务功能，并且获得更新灵活的网络能力。Service Mesh 便是在这样的背景下诞生的。</p>
</div>
<div class="paragraph">
<p><a href="https://buoyant.io">Buoyant</a> 发布的 <a href="https://linkerd.io/">Linkerd</a> 是Service Mesh第一个商业实现，而Google、IBM 和 Lyft 发布的 <a href="https://istio.io/">Istio</a> 引入了控制平面的概念，将服务管理从数据平面抽象出来，有点像 SDN 的架构。这样明显领先的设计让 Linkerd 面临巨大压力，于是 Buoyant 在2017年底发布了 <a href="https://buoyant.io/2017/12/05/introducing-conduit/">Conduit</a> 以便和 Istio 竞争。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://istio.io/docs/concepts/what-is-istio/arch.svg" alt="arch">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cloud_native">2.2. Cloud Native</h3>
<div class="paragraph">
<p>2013年，Spring 的 Matt Stine 提出了云原生(Cloud Native)的概念，描绘了面向云的架构需要关注的方向和需要达成的目标。今天我们可以看到，相对传统应用，云原生在架构的各个层面都发生了变革。而且互相依赖，自成一体，例如Service Mesh会重度依赖服务编排。在架构设计上，我们的关注点更多，但解决方案也越发的趋同。</p>
</div>
<div class="literalblock">
<div class="title">cloud native abstractions</div>
<div class="content">
<pre>       Virtual machines -&gt; Containers
           Data centers -&gt; Orchestrated envs
    Hardware redundancy -&gt; Design for failure
                Servers -&gt; Services
      IP addresses, DNS -&gt; Services discovery
      Server monitoring -&gt; Services monitoring
Monolithic applications -&gt; Microservices
                 TCP/IP -&gt; gRPC, REST</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dubbo_vs_spring_cloud">2.3. Dubbo vs Spring Cloud</h3>
<div class="paragraph">
<p>在 Spring cloud 出现之前，Dubbo 是国内互联网界非常流行的 RPC 框架。虽然被ali荒废了几年，但其基本功能并没有落后太多，现在被ali重新启动，并作为aliyun的微服务解决框架使用，还是可以保持下关注。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-right valign-top">Microservice features</th>
<th class="tableblock halign-center valign-top">Dubbo</th>
<th class="tableblock halign-center valign-top">Spring Cloud</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>Service discovery</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Zookeeper</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Eureka</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>Invoke mode</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RPC</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RESTful API</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>Circuit breaker</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Hystrix</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>Load balance</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Ribbon</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>Service route</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Zuul</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>Distributed configuration</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Config</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>Distributed message</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Bus</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_参考">参考</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a href="http://cloud.spring.io/spring-cloud-static/spring-cloud.html" class="bare">http://cloud.spring.io/spring-cloud-static/spring-cloud.html</a></p>
</li>
<li>
<p><a href="http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html" class="bare">http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html</a></p>
</li>
<li>
<p><a href="http://callistaenterprise.se/blogg/teknik/2017/02/17/go-blog-series-part1/">Go Microservices blog series</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/hHzDa1T_UKPB97ttFRaDCQ">Service Mesh 时代的选边与站队</a></p>
</li>
<li>
<p><a href="https://www.kubernetes.org.cn/2737.html">Kubernetes，微服务以及 Service Mesh</a></p>
</li>
<li>
<p><a href="http://bit.ly/8stepsawesome">8 Steps to Becoming Awesome with Kubernetes</a></p>
</li>
<li>
<p><a href="https://medium.com/@DockerTurtle/service-mesh-the-nervous-system-of-microservices-9393ed1ffa5c">"Service mesh"&#8201;&#8212;&#8201;the Nervous system of Microservices</a></p>
</li>
<li>
<p><a href="https://content.pivotal.io/ebooks/migrating-to-cloud-native-application-architectures">Migrating to Cloud Native Application Architectures</a> by Matt Stine (<a href="https://github.com/rootsongjc/migrating-to-cloud-native-application-architectures">中文版</a>)</p>
</li>
</ul>
</div>
</div>
</div>
    </article>
    <section class="comment">
        <div id="disqus_thread"></div>
    </section>
</section>
<footer class="footer">
    Copyright © 2020 | Powered by <a href="https://github.com/chenhm/java-static-blog" target="_blank">java-static-blog</a>
</footer>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-core.min.js" integrity="sha256-Y+Budm2wBEjYjbH0qcJRmLuRBFpXd0VKxl6XhdS4hgA=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-ht8ay6ZTPZfuixYB99I5oRpCLsCq7Do2LjEYLwbe+X8=" crossorigin="anonymous"></script>
</body>
</html>