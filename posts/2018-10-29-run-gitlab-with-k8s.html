<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, user-scalable=no">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="manifest" href="/manifest.json">
    <link href="/static/asciidoctor.min.css" rel="stylesheet"/>
    <link href="/static/build.css" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/themes/prism.min.css" integrity="sha256-77qGXu2p8NpfcBpTjw4jsMeQnz0vyh74f5do0cWjQ/Q=" crossorigin="anonymous" />
</head>
<body>
<div id='app'>
    <header class="header">
        <div class="container">
            <!--start: Navigation -->
            <a href="/" class="brand">On the Road</a>
<!--            <ul class="nav">-->
<!--                <li><a href="/list/">Blogs</a></li>-->
<!--                <li><a href="/slides/">Slides</a></li>-->
<!--                <li><a href="/about/">About</a></li>-->
<!--            </ul>-->
        </div>
        <!--end: Navigation -->
        <div style="clear: both"></div>
        <search-bar v-if="isPageList"></search-bar>
    </header>

<section class="post-view">
    <article>
     
     <h1>基于Kubernetes的Gitlab runner环境搭建</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_环境准备">1. 环境准备</a>
<ul class="sectlevel2">
<li><a href="#_升级系统内核">1.1. 升级系统内核</a></li>
<li><a href="#_安装docker">1.2. 安装docker</a></li>
</ul>
</li>
<li><a href="#_kubernetes的安装配置">2. Kubernetes的安装配置</a>
<ul class="sectlevel2">
<li><a href="#_安装_kubeadm">2.1. 安装 kubeadm</a></li>
<li><a href="#_初始化_kubernetes">2.2. 初始化 kubernetes</a></li>
<li><a href="#_创建访问账号和rbac">2.3. 创建访问账号和RBAC</a></li>
</ul>
</li>
<li><a href="#_gitlab的安装配置">3. Gitlab的安装配置</a>
<ul class="sectlevel2">
<li><a href="#_安装_gitlab">3.1. 安装 gitlab</a></li>
<li><a href="#_设置_gitlab_runner">3.2. 设置 gitlab-runner</a></li>
<li><a href="#_测试pipeline脚本">3.3. 测试pipeline脚本</a></li>
</ul>
</li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://chenhm.com">Chen Hongming</a></p>
</div>
<div class="paragraph">
<p>本文以单节点kubernetes(k8s)上安装gitlab测试环境为例，介绍了k8s和gitlab的基础知识，方便大家学习使用新的DevOps环境。例子中的环境为Redhat 7.4，kubernetes 1.12，Gitlab CE 11.4。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_环境准备">1. 环境准备</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_升级系统内核">1.1. 升级系统内核</h3>
<div class="paragraph">
<p>虽然Docker官方要求Linux内核版本不低于3.10，但overlay2文件系统需要4.0以上的内核版本。RHEL在3.10.0-514以上通过安装时设置 <code>overlay2.override_kernel_check=true</code> 参数也可以强制使用overlay2，但简单起见，我们直接升级内核到最新的稳定版。不升级内核使用overlay2参考 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/#configure-docker-with-the-overlay-or-overlay2-storage-driver">这里</a>。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>导入key</p>
<div class="literalblock">
<div class="content">
<pre>rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</pre>
</div>
</div>
</li>
<li>
<p>安装elrepo的yum源</p>
<div class="literalblock">
<div class="content">
<pre>rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</pre>
</div>
</div>
</li>
<li>
<p>安装内核</p>
<div class="literalblock">
<div class="content">
<pre>yum --enablerepo=elrepo-kernel install kernel-ml-devel kernel-ml</pre>
</div>
</div>
</li>
<li>
<p>查看默认启动顺序</p>
<div class="literalblock">
<div class="content">
<pre>awk -F\' '$1=="menuentry " {print $2}' /etc/grub2.cfg
Red Hat Enterprise Linux Server (4.18.14-1.el7.elrepo.x86_64) 7.4 (Maipo)
Red Hat Enterprise Linux Server (3.10.0-693.el7.x86_64) 7.4 (Maipo)
Red Hat Enterprise Linux Server (0-rescue-90676f243b93486d809800b50e88e186) 7.4 (Maipo)</pre>
</div>
</div>
<div class="paragraph">
<p>设置默认启动的顺序是从0开始，新内核是从头插入，目前位置在0，而旧的3.10是在1。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>grub2-set-default 0</pre>
</div>
</div>
<div class="paragraph">
<p>然后reboot重启</p>
</div>
</li>
<li>
<p>删除旧的内核</p>
<div class="literalblock">
<div class="content">
<pre>yum remove kernel</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>更详细的步骤参考 <a href="https://www.howtoforge.com/tutorial/how-to-upgrade-kernel-in-centos-7-server/" class="bare">https://www.howtoforge.com/tutorial/how-to-upgrade-kernel-in-centos-7-server/</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_安装docker">1.2. 安装docker</h3>
<div class="paragraph">
<p>安装docker参考 <a href="https://docs.docker.com/install/linux/docker-ce/centos/">官方指引</a> 是非常简单的，由于我的服务器在一台代理后面，所以需要额外设置docker的代理服务器，否则docker无法拉取镜像。</p>
</div>
<div class="listingblock">
<div class="title">install-docker.sh</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">export {http,https}_proxy=http://hubproxy:8080
export no_proxy=localhost
yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2

yum-config-manager \
    --add-repo \
        https://download.docker.com/linux/centos/docker-ce.repo

#在RHEL 7.4中安装最新版的docker ce需要手工更新下，如果系统和docker都是最新版本则不需要
#yum install -y http://mirror.centos.org/centos/7/extras/x86_64/Packages/container-selinux-2.68-1.el7.noarch.rpm

yum install -y docker-ce

#设置docker的代理服务器
mkdir -p /etc/systemd/system/docker.service.d/
cat &lt;&lt;EOF &gt; /etc/systemd/system/docker.service.d/http-proxy.conf
[Service]
Environment="HTTP_PROXY=http://hubproxy:8080" "HTTPS_PROXY=http://hubproxy:8080" "NO_PROXY=localhost,127.0.0.1"
EOF

systemctl daemon-reload
systemctl enable docker
systemctl start docker</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_kubernetes的安装配置">2. Kubernetes的安装配置</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_安装_kubeadm">2.1. 安装 kubeadm</h3>
<div class="paragraph">
<p>kubeadm是最主要的Kubernetes部署工具之一，它可以帮助完成k8s集群的初始化。 <code>kubeadm</code> 依赖 <code>kubelet</code> 来启动Master组件， <code>kubelet</code> 运行在集群的每个节点上用于启动Pod，同时我们还需要 <code>kubectl</code> 来管理集群。详细安装步骤参考 <a href="https://kubernetes.io/docs/setup/independent/install-kubeadm/#installing-kubeadm-kubelet-and-kubectl" class="bare">https://kubernetes.io/docs/setup/independent/install-kubeadm/#installing-kubeadm-kubelet-and-kubectl</a></p>
</div>
<div class="listingblock">
<div class="title">install-kubeadm.sh</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
EOF
setenforce 0
yum install -y kubelet kubeadm kubectl

# for RHEL/CentOS 7
cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sysctl --system

# enable read-only port for heapster
sed -i 's/KUBELET_EXTRA_ARGS=/KUBELET_EXTRA_ARGS=--read-only-port 10255 /' /etc/sysconfig/kubelet

systemctl enable kubelet &amp;&amp; systemctl start kubelet</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_初始化_kubernetes">2.2. 初始化 kubernetes</h3>
<div class="paragraph">
<p>初始化k8s master节点最简单的方法就是直接执行 <code>kubeadm init</code>  ，这个命令会执行一系列的步骤：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>系统状态预检查</p>
</li>
<li>
<p>生成自签名CA并签名每个组件</p>
</li>
<li>
<p>生成kubeconfig用于kubelet连接API server</p>
</li>
<li>
<p>为Master组件生成Static Pod manifests，并放到 /etc/kubernetes/manifests 目
录中，kubelet会监视这个目录并初始化Pod</p>
</li>
<li>
<p>配置RBAC并设置Master node只运行控制平面组件</p>
</li>
<li>
<p>创建附加服务，比如kube-proxy和kube-dns</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面的脚本我们在 <code>init</code> 的时候启用了一些扩展API供后面使用。 <code>init</code> 后的集群还需要安装网络插件CNI用于集群网络管理，这里我们使用WeaveNet的CNI实现。最后为了便于查看集群状态，我们还安装了Kubernetes Dashboard，并用NodePort的形式将它暴露到本地的30443端口。</p>
</div>
<div class="listingblock">
<div class="title">startup-kube.sh</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#kubeadm config images pull
swapoff -a

cat &lt;&lt;EOF &gt; kubeadm.conf
apiVersion: kubeadm.k8s.io/v1alpha3
kind: ClusterConfiguration
apiServerExtraArgs:
  enable-admission-plugins: "NamespaceLifecycle,LimitRanger,ServiceAccount,NodeRestriction,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodPreset"
  runtime-config: "extensions/v1beta1=true,extensions/v1beta1/networkpolicies=true,admissionregistration.k8s.io/v1alpha1=true,settings.k8s.io/v1alpha1=true,api/all=true"
EOF

export {http,https}_proxy=http://hubproxy:8080
curl -L -o weave.yaml "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"
curl -L -o kubernetes-dashboard.yaml "https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml"
unset http_proxy
unset https_proxy

kubeadm init --config=kubeadm.conf

cat &lt;&lt;EOF &gt;&gt; kubernetes-dashboard.yaml
---
# ------------------- Dashboard Service ------------------- #

kind: Service
apiVersion: v1
metadata:
  labels:
    k8s-app: kubernetes-dashboard
  name: kubernetes-dashboard
  namespace: kube-system
spec:
  ports:
    - port: 443
      targetPort: 8443
      nodePort: 30443
  type: NodePort
  selector:
    k8s-app: kubernetes-dashboard
EOF


export KUBECONFIG=/etc/kubernetes/admin.conf

# modprobe -a ip_vs ip_vs_rr ip_vs_wrr ip_vs_sh

# using weave net as CNI
# sysctl net.bridge.bridge-nf-call-iptables=1
kubectl apply -f weave.yaml

# Allowing pod scheduling on the master node
kubectl taint nodes --all node-role.kubernetes.io/master-

kubectl apply -f kubernetes-dashboard.yaml

#CentOS firewalld is completely incompatible with kubernetes
systemctl disable firewalld
systemctl stop firewalld</code></pre>
</div>
</div>
<div class="paragraph">
<p>等待Pod启动完成后可以通过 <a href="https://host:30443" class="bare">https://host:30443</a> 访问dashboard。</p>
</div>
</div>
<div class="sect2">
<h3 id="_创建访问账号和rbac">2.3. 创建访问账号和RBAC</h3>
<div class="paragraph">
<p>在上一步访问dashboard的时候会发现提示访问token，这是因为刚创建好的k8s还没有访问账号， <a href="https://github.com/kubernetes/dashboard/wiki/Creating-sample-user">这里</a> 有个简单的账号设置官方示例。我们则需要多设一些权限供gitlab使用。</p>
</div>
<div class="listingblock">
<div class="title">user.yaml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kube-system
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: default
  name: pod-and-pod-logs-reader
rules:
- apiGroups: [""]
  resources: ["pods", "pods/log"]
  verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: admin-user-log
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: pod-and-pod-logs-reader
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kube-system</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行以下脚本设置RBAC并获取访问Token。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">kubectl apply -f user.yaml

kubectl create clusterrolebinding my-cluster-admin \
 --clusterrole=cluster-admin \
 --user=system:serviceaccount:default:default

kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gitlab的安装配置">3. Gitlab的安装配置</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_安装_gitlab">3.1. 安装 gitlab</h3>
<div class="paragraph">
<p>由于gitlab组件众多，最简单的方式就是使用官方docker image运行。为了将docker内部的gitlab暴露出来，需要添加 <code>external_url</code> 参数，详细配置参考 <a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/configuration.md#configuration-options">configuration-options</a>，可以根据自己情况修改下面的启动脚本。</p>
</div>
<div class="listingblock">
<div class="title">run-gitlab.sh</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># 31480 is my external port, you can set it to whatever you like, but need to be consistent
cat &lt;&lt;EOF &gt; gitlab.rb
external_url 'http://host:31480'
EOF

docker run -d --name gitlab -p 31480:31480 -v "`pwd`/gitlab.rb:/etc/gitlab/gitlab.rb" gitlab/gitlab-ce</code></pre>
</div>
</div>
<div class="paragraph">
<p>等docker起来后访问 <a href="http://host:31480" class="bare">http://host:31480</a> 即可登录gitlab，第一次访问会要求设置root账户的密码。</p>
</div>
</div>
<div class="sect2">
<h3 id="_设置_gitlab_runner">3.2. 设置 gitlab-runner</h3>
<div class="paragraph">
<p>Gitlab实际执行的job都是在runner节点上运行的，这里我们使用刚刚创建的k8s作为runner环境，让gitlab调度k8s创建pod执行job。gitlab 官方文档仅描述了如何在 <a href="https://docs.gitlab.com/runner/install/kubernetes.html">k8s 中启动gitlab runner</a>，但通常在运行之前需要先注册runner，我们参考 <a href="https://gitlab.com/gitlab-org/gitlab-runner/issues/2002#note_35828301">这个issue</a> 利用initContainer完成注册。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>找到注册token。访问 <a href="http://host:31480/admin/runners，会看到一段随机的" class="bare">http://host:31480/admin/runners，会看到一段随机的</a> <code>registration token</code>。</p>
</li>
<li>
<p>修改下面yaml配置中的 <code>REGISTRATION_TOKEN</code> 参数值为上一步查询到的token，然后执行 <code>kubectl apply -f gitlab-runner.yaml</code> 完成注册。</p>
<div class="listingblock">
<div class="title">gitlab-runner.yaml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: gitlab-runner
  labels:
    app: gitlab-runner
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: gitlab-runner
    spec:
      initContainers:
        - name: init-runner
          image: gitlab/gitlab-runner:latest
          args:
            - register
          env:
            - name: CI_SERVER_URL
              value: "http://host:31480/"
            - name: REGISTER_NON_INTERACTIVE
              value: "true"
            - name: REGISTRATION_TOKEN
              value: "BsxzTZQzLayGpqS8qwkx"
            - name: RUNNER_TAG_LIST
              value: "kube,test"
            - name: RUNNER_EXECUTOR
              value: kubernetes
            - name: RUNNER_REQUEST_CONCURRENCY
              value: "10"
            # Must use privileged mode for docker-in-docker
            - name: KUBERNETES_PRIVILEGED
              value: "true"
            # More variables as needed (see below)
          volumeMounts:
            - mountPath: /etc/gitlab-runner
              name: config
            - mountPath: /etc/ssl/certs
              name: cacerts
              readOnly: true
        - name: init-runner-volume
          image: alpine
          command: ["sh", "-c"]
          # Append hostpath mount to configuration because there is no env variable for it
          # https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/issues/2578
          args:
            - |
              cat &lt;&lt;EOF &gt;&gt; /etc/gitlab-runner/config.toml
                [[runners.kubernetes.volumes.host_path]]
                name = "docker-sock"
                mount_path = "/var/run/docker.sock"
                host_path = "/var/run/docker.sock"
              EOF
          volumeMounts:
            - mountPath: /etc/gitlab-runner
              name: config
      containers:
        - name: runner
          image: gitlab/gitlab-runner:latest
          args:
            - run
          volumeMounts:
            - mountPath: /etc/gitlab-runner
              name: config
            - mountPath: /etc/ssl/certs
              name: cacerts
              readOnly: true
      volumes:
        - name: cacerts
          hostPath:
            path: /usr/share/ca-certificates/mozilla
        - name: config
          emptyDir: {}</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_测试pipeline脚本">3.3. 测试pipeline脚本</h3>
<div class="paragraph">
<p>我们建立一个调用redis服务的pipeline脚本来体验gitlab CI的能力。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>新建一个空项目。</p>
</li>
<li>
<p>在项目根路径创建 <code>.gitlab-ci.yml</code>  文件，这是gitlab默认的CI配置文件路径。</p>
<div class="listingblock">
<div class="title"><em>.gitlab-ci.yml</em></div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">services:
- redis <b class="conum">(1)</b>

variables:
  # Configure redis service (https://hub.docker.com/_/redis/)
  # Here's nothing to configure :)

connect:
  # Connect to redis
  image: redis <b class="conum">(2)</b>
  tags:
  - kube <b class="conum">(3)</b>
  script:
  - redis-cli -h localhost PING <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>拉取redis image并作为服务启动。</p>
</li>
<li>
<p>使用redis image作为connect job的执行环境。</p>
</li>
<li>
<p>指定在tag包含kube的runner执行</p>
</li>
<li>
<p>由于redis service和connect job这两个docker都在同一个Pod内执行，它们共享相同的localhost地址，我们直接使用localhost访问另一个docker上的redis服务。</p>
</li>
</ol>
</div>
</li>
<li>
<p>访问项目的 CI/CD&#8201;&#8212;&#8201;Pipelines 页面查看job执行情况。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>至此我们已成功集成了Gitlab和k8s，下一篇将会深入介绍一些功能。</p>
</div>
</div>
</div>
</div>
    </article>
    <section class="comment">
        <div id="disqus_thread"></div>
    </section>
</section>
<footer class="footer">
    Copyright © 2020 | Powered by <a href="https://github.com/chenhm/java-static-blog" target="_blank">java-static-blog</a>
</footer>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-core.min.js" integrity="sha256-Y+Budm2wBEjYjbH0qcJRmLuRBFpXd0VKxl6XhdS4hgA=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-ht8ay6ZTPZfuixYB99I5oRpCLsCq7Do2LjEYLwbe+X8=" crossorigin="anonymous"></script>
</body>
</html>